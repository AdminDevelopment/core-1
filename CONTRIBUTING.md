# License

By contributing your code, you agree to license your contribution under the MIT License.

You also need to sign the [CLA](https://cla-assistant.io/bountysource/core) before your Pull Request is accepted.
When you send your PR check the Pull Request page, it wil have a Link to signing the CLA.

# How to Contribute
Keep in mind this standardized setup is a work in progress, if you have any trouble please open an issue on the issue tracker and give as much info as possible.

First of all you need [Docker](https://www.docker.com/what-docker) and [Docker Compose](https://docs.docker.com/compose/install/) installed.

## Environment
Bountysource uses Environment Variables for a lot of things. There's a suggested `.env.dev` file at the root directory that is loaded by the `docker-compose.yml`.

It's recommended that you take a good look at the entire `.env.dev` file and, if necessary, change it to suit your needs, but at the very least you should pay attention to the following variables:

0. URL for Buntysource API: `BOUNTYSOURCE_API_URL`
0. URL for Bountysource Website (Front-End): `BOUNTYSOURCE_WWW_URL`
0. URL for the Database: `DATABASE_URL`
0. Environment for Rails and Rake: `RAILS_ENV` and `RAKE_ENV`, respectively.

### About the `DATABASE_URL`
This is a url, in the usual form `protocol://user:password@host/path`, just without the `password` since the postgres image doesn't use a password.
The `path` part is the database name and you can change that without any issues, but before changing anything else keep in mind that the `host` matches the service in the `docker-compose.yml` and `docker-compose-test.yml` files, and the `user` matches the default on the `postgres` docker image.
``` bash
DATABASE_URL=postgres://postgres@pgsql/bountysource_dev
```

### The URLs
Remember to keep the `API` and `WWW` URLs accessible from Outside Docker, either by changing your `hosts` file or leaving them as `0.0.0.0`:
``` bash
BOUNTYSOURCE_API_URL=http://0.0.0.0:3000/
BOUNTYSOURCE_WWW_URL=http://0.0.0.0:3000/
```

## Standardized Setup for First-time use

There is some setup and configuration you need to do before the project will run, this section covers those.

Mainly, you need to create the Sphinx configuration file as well as Symlink it to its expected location before running the Search Daemon (Default command Sphinx image runs). You also have to generate the database and search indexes.

0. Build container and start database.  
  We only need to start the database manually because we will use `--no-deps` when we run the main container

  ``` bash
  docker-compose build
  docker-compose run -d pgsql
  ```

0. When we first run the main container to call `rake` we need to use `--no-deps`, as the Sphinx container needs the configuration file generated by `ts:configure` (Unless you pass a command to it, as when we create the Symlink below).
  0. `db:setup` sets up the Database
  0. `ts:configure` generates configuration file required by Sphinx  

  ``` bash
  docker-compose run --no-deps bountysource rake db:setup ts:configure
  ```

0. Now we Symlink the Sphinx configuration file in the Sphinx image, which means we don't need `--no-deps` from now on, nor run the other containers manually.

  ``` bash
  docker-compose run sphinx ln -Ts /app/config/development.sphinx.conf /usr/local/etc/sphinx.conf
  ```

0. Lastly we index our data for Sphinx (The Search Engine).  

  ``` bash
  docker-compose run bountysource rake ts:generate ts:index
  ```

Now the Setup is done and everything should be working.

## How to use the containers - Cheatsheet
### The Basics
- To run the Rails server and make it available on port `3000`, a simple `up` command will suffice:

  ``` bash
  docker-compose up
  ```

- To run the console you need to pass the `rails c` command to the container, and there are two ways to do it:

  0. If the container is not running, you have to use `run`
    ``` bash
    docker-compose run bountysource rails c
    ```

    0. If the container is running, you can use `exec`, which connects to the running container.
      ``` bash
      docker-compose exec bountysource rails c
      ```

- You can also simply open `bash` and do pretty much anything on the container, using either `run` or `exec`.
``` bash
docker-compose run bountysource bash
docker-compose exec bountysource bash
```

### Some things you want to keep in mind
- The database as well as the Search index use volumes so your data is persisted across runs, unless you remove the containers, so the one-time setup really means one-time.

- Sphinx needs a config file to run. This file is generated by running `rake ts:configure` on the main container.

  The `ts:configure` task is the reason for the `--no-deps` during the build, and if you delete the configuration file you will need to recreate it as you did on the first setup, using `--no-deps`, and possibly Symlink it again.

- To keep things simple while also avoiding bloating the sphinx configuration file, the `sphinx` and `bountysource` containers share a volume containing the `/app` folder, which means the Sphinx logs (as well as many other files really) are accessible from the main container.

- If you change data and you're not seeing the changes in the Search, you may need to run the Sphinx rake tasks:
  0. `ts:index` indexes data using the files in `app/indices`, while
  0. `ts:generate` indexes data using the Sphinx definitions on the models.
- If you need to, you can send arbitrary commands to any container (Not only the main container, but also the database and Sphinx containers) by using `docker-compose exec [container] [command]` and `docker-compose run [container] [command]`.

## Before sending a Pull Request

Before sending a Pull Request you should make sure all tests are passing:
``` bash
docker-compose -f docker-compose-test.yml build
docker-compose -f docker-compose-test.yml up
```
